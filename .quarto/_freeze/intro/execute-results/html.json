{
  "hash": "a80934035dc576581ef605970613ac35",
  "result": {
    "markdown": "# Data Manipulation\n\n\n::: {.cell mesagge='false'}\n\n```{.r .cell-code}\nrm(list = ls())\nlibrary(tidyverse)\nlibrary(rstatix)\nlibrary(easystats)\nlibrary(ggfortify)\nlibrary(ggpubr)\nlibrary(jtools)\nlibrary(pubh)\nlibrary(sjlabelled)\nlibrary(sjPlot)\nlibrary(sjmisc)\n\nimport::from(latex2exp, TeX)\ntheme_set(sjPlot::theme_sjplot2(base_size = 10))\ntheme_update(legend.position = \"top\")\noptions('huxtable.knit_print_df' = FALSE)\noptions('huxtable.autoformat_number_format' = list(numeric = \"%5.2f\"))\n```\n:::\n\n\n## Overview\n\nThe first step in data analysis that involves `R` will be acquiring your data in an appropriate format, either by entering it directly into `R`, importing it from a spreadsheet or other format, or by opening a pre-existing `R` data file.\n\nIn this laboratory, we will look at performing simple data handling in `R`. The most important part of this lab is to get you familiar with the software.\n\nOnce you have completed this lab, you should feel comfortable:\n\n-   Creating variables in `R`.\n-   Understanding the difference between continuous variables and categorical ones (factors).\n-   Transforming data (e.g., converting from pounds to kilograms, calculating BMIs from weights and heights, log transformations, etc.).\n-   Extracting subsets of your data.\n-   Assigning labels to variables and categories within variables.\n-   Saving your data.\n-   Using `R`'s help system.\n-   Importing data in `R` from an Excel spreadsheet.\n-   Creating script files.\n\n> ## Summary of New Commands\n\n| **Command**          | **Library**  | **Function**                                               |\n|----------------------|--------------|------------------------------------------------------------|\n| **%\\$%**             | *magrittr*   | Exposition pipe operator                                   |\n| **%\\>%**             | *magrittr*   | Forward pipe operator                                      |\n| **%in%**             | *base*       | Value matching                                             |\n| **as_tibble**        | *tibble*     | Coerces objects into tibbles                               |\n| **c**                | *base*       | Concatenates values                                        |\n| **copy_labels**      | *sjlabelled* | Copies labels from a data frame                            |\n| **count**            | *dplyr*      | Counts observations by group                               |\n| **data**             | *base*       | Loads data from `R` packages                               |\n| **factor**           | *base*       | Defines *factors*                                          |\n| **filter**           | *dplyr*      | Filters data frames, given conditions                      |\n| **freq_table**       | *rstatix*    | Frequency tables for categorical variables                 |\n| **frq**              | *sjmisc*     | Frequency tables for categorical variables                 |\n| **glimpse**          | *tibble*     | Displays information about a dataset                       |\n| **head**             | *base*       | First rows of a data frame                                 |\n| **help (?)**         | *base*       | Help function                                              |\n| **install.packages** | *utils*      | Installs packages in the system                            |\n| **is.factor**        | *base*       | Evaluates if a variable is a factor or not                 |\n| **library**          | *base*       | Loads (attaches) functions from a package                  |\n| **length**           | *base*       | Number of observations in a variable                       |\n| **levels**           | *base*       | Levels of categorical variables                            |\n| **mutate**           | *dplyr*      | Transforms/generates variables                             |\n| **mean**             | base         | Calculates the arithmetic mean                             |\n| **max**              | base         | Calculates maximum value                                   |\n| **names**            | *base*       | Column names of variables in a data frame                  |\n| **nrow**             | *base*       | Number of rows (observations) in data frames               |\n| **read_csv**         | *readr*      | Loads files with `csv` format/extension                    |\n| **read_rds**         | *readr*      | Loads RDS files                                            |\n| **relevel**          | *base*       | Changes the reference category                             |\n| **rep**              | *base*       | Replicates numbers or characters                           |\n| **rm**               | *base*       | Deletes (*removes*) objects from the workspace             |\n| **round**            | *base*       | Rounds variables                                           |\n| **RSiteSearch**      | *utils*      | Searches `R` functions in the web                          |\n| **select**           | *dplyr*      | Selects variables from a data frame or tibble              |\n| **setwd**            | *base*       | Sets the working directory (path)                          |\n| **tibble**           | *tibble*     | Constructs *tibbles*                                       |\n| **var_labels**       | *sjlabelled* | Assigns labels to variables                                |\n| **View**             | *utils*      | Displays data frames                                       |\n| **which**            | *base*       | Finds the positions where the stated conditionals are true |\n| **which.max**        | *base*       | Finds the position of the maximum value                    |\n| **with**             | *base*       | Evaluates commands in a defined data frame or tibble       |\n| **write_csv**        | *readr*      | Exports files with `csv` format/extension                  |\n| **write_rds**        | *readr*      | Writes RDS files                                           |\n\n## RStudio\n\nA typical session on `RStudio` would look something like @fig-fig1.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![`RStudio` displaying a typical `.Rmd` Markdown script file on the top left corner.](figures/RStudio.png){#fig-fig1}\n:::\n:::\n\n\n`RStudio` can have up to four panels open (displaying information):\n\n1.  **Source** panel (top left). This panel shows the *script* files.\n2.  **Console** panel (bottom left). This panel is where you interact with the program to perform an analysis. It shows the path of the current working directory at the top.\n3.  **Workspace** panel (top right). You can select what to show in here. In @fig-fig1, it shows information about the workspace, like currently loaded objects (*Environment*) and the *History* of our commands.\n4.  **Display** panel (bottom right). You can select what to show in here. In @fig-fig1, it shows *Files*, the *Help* files, generated *Plots*, *Packages* available on your `R` installation and the *Viewer*.\n\n## Scripts\n\nFiles that document our analysis are known as *scripts*, and they open on the *Source* panel. The standard script file has a `.R` extension and can be opened with any text editor.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Example of a `.R` script document.](figures/Script.png){#fig-fig2}\n:::\n:::\n\n\n@fig-fig2 displays an example of a *script* file. These kind of files are intended to be read by `R`, so any text that is not part of a command, has to be *commented*. `R` will interpret anything written after a `#` (on the same line) as a comment.\n\nLet's clarify the first set of lines from the script file, as shown in @fig-fig2.\n\n1.  The first line is a comment and gives the name of the file, so, it is not needed, but it is good to have.\n2.  The second line is a comment about the content of the script. It can be a short or long description. The important thing to remember is that once that you start a new line, for example for writing a different paragraph, you would need to include the `#` symbol at the beginning of each new line.\n3.  The third line is a comment about the author.\n4.  The fourth line is a comment about the date.\n5.  The sixth line sets the working directory. As explained in the preface, this can be done with the menus and it's not needed when working in `R` projects.\n6.  Line 7 loads the `pubh` package.\n7.  Line 9 estimates measures of association of the *exposure* `treat` on the *outcome* `fate` from the `Bernard` data set. \\#\\# Notebooks\n\nThe disadvantage of `.R` scripts is that you cannot produce a single document with both the analysis and the results of such analysis. Notebooks, permit us to record text, commands and results (including plots). We will be using Notebooks to document our analysis on both *PUBH 725* and *PUBH 726*.\n\nWe will start by creating a mock notebook, using the template that comes with the `pubh` package [@pubh]. Open `RStudio` and select `File > New File > R Markdown...`.\n\n:::{.callout-caution}\nFor this paper, I will use the term of **Notebooks** for R Markdown (`.Rmd`) documents. Do NOT select `File > New File > R Notebook` to create the Notebook.\n:::\n\nA window will pop-up like the one shown in @fig-fig3, select: `From Template > PUBH Template`.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Window for creating a new `R` Markdown file (Notebook).](figures/Notebook1.png){#fig-fig3}\n:::\n:::\n\n\nClick `OK` or type the `Return` key. Have a look at the template; we will edit the script later. For the moment, Let's run the template as it is. To execute the Notebook, you only need to click on the `Knit` button which can be found in the *Source* panel. When you click *knit* (see **1** in @fig-fig4) for the first time, it will ask for a name to save your file. Give a name like *Lab1*. The result will appear on the *Display* panel, and two files will be created: *Lab1.Rmd* is the script, and *Lab1.html* is the output that you can open with any web browser.\n\n:::{.callout-tip}\nWord can also open *html* files.\n:::\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Source panel for a Notebook. The following parts are highlighted: **1.** The *Knit* button to *compile* the file. **2.** The *Insert* button to insert `R` code. **3.** The *Run* button to pass *chunks* to the console. **4** The *Outline* and *Markup* buttons. **5.** The desired output of the document. **6.** Cog button to access chunk options and buttons for running the *chunk*.](figures/SourcePanel.png){#fig-fig4}\n:::\n:::\n\n\nLet's create the Notebook for the first laboratory. Change the title to *Data management* and edit the author field.\n\nCodes are inserted in sections called *chunks* or *blocks*. Go to the end of the script and click on `Insert > R` (see **2** in @fig-fig4). Your cursor will be, by default, where you can insert your commands. The easiest thing to do is just to copy from the lab book and paste the code in the chunk.\n\nIn @fig-fig4, the option `message = FALSE` was added to the first chunk, to hide messages from the output. You can change the options from a chunk by clicking on the *Cog button* (see **6** in @fig-fig4). Compile the *RMardown* script by clicking on the *Knit* button (see **1** in @fig-fig4).\n\n:::{.callout-tip}\nFor a quick reference on Markdown, go to `Help > Markdown Quick Reference`.\n:::\n\nWhen you *Knit* the document, it compiles the full document and displays the results on the *Display* panel. Sometimes, we want to check a particular command. For doing that, you can *transfer* your command from the *script* file by clicking on the small green arrow at the right of the code (see **3** and **6** in @fig-fig4). Depending on your preferences, the results will show on the *Console* panel or directly in your script file.\n\n:::{.callout-warning}\nThe console has no history of what you *knit*, that means that if you are testing a particular code, on a dataset that has not been loaded yet on the *Console* panel, you will have an error message. To keep it safe, if you want to work in an interactive way with the *Console*, run each *chunk* as you progress and *knit* only when you want to look at the whole document.\n:::\n\n### Accessing help\n\nWhen you do not know about the specific options or syntax of a particular command, you can access the help files. For example, Let's say you want to learn more about the `mean` function. One way is to use the `help` command is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhelp(mean)\n```\n:::\n\n\n:::{.callout-note}\nThe general syntax for a command in `R` is: `command(object, options)`; where `command` is a function available on the current loaded `R` packages or created for the current session.\n:::\n\nAs an alternative, we can use the question mark, without any parenthesis as in:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?sd\n```\n:::\n\n\nIt's important that you get familiar with help files. At the end of each help file, you can see some examples. You can select a particular example and then type Ctrl + Return (Windows) or Command + Return (Macintosh) to transfer the selection to the console.\n\n:::{.callout-warning}\n1.  The help will only look for documentation on functions that are part of the **attached** packages.\n2.  Use the `help` command **only** in the Console panel. **DO NOT** include `help` commands as part of your script files.\n:::\n\nWhen we do not know the name of the function, or it may be part of a package that is installed in the computer, but not loaded yet, you can search by using double question marks. For example, Let's say that you would like to know how to perform diagnostic tests (e.g., sensitivity, specificity, etc.), in that case, you would type (please note the use of quotes):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?? \"diagnostic tests\"\n```\n:::\n\n\nWhen we use `??` the system searches for functions associated with current installed packages. When we need to make a further search on the web, we can use `RSiteSearch` in the *Console* panel. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRSiteSearch(\"meta-analysis\")\n```\n:::\n\n\n> **Exercise:** Find out what the `names` command does.\n>\n> **Answer:** Gives the names from an `R` object. We use this to know the variables contained in a given dataset (`data.frame` or `tibble` in `R`).\n\n### Browsing help\n\nOther times, you just want to browse the functions of a particular package of interest, to find new commands. For example, go to the **Display** panel and select the **Packages** tab. Look for the package `pubh` and click on it. A help file will open with the description of all functions and data that are part of that package. You can click on any of the listed functions to gather more information. Some packages have also **Vignettes** which are more helpful as they guide you to the use of the functions contained in the package.\n\nIn the help file of `pubh` click on `User guides, package vignettes and other documentation`. Next, select the first one: `Introduction to the pubh package`. You do not have to read through that vignette today, but now you know how to access vignettes.\n\n## Packages\n\nWhen you open `R`, it loads a standard number of *packages*, each one of them includes a particular set of functions and data. We can extend the number of available functions by loading more packages into the system.\n\nWhen you start with the template provided by the `pubh` package, the first chunk loads recommended packages for *PUBH 725* and *PUBH 726* into the session. When loading a package *required* packages are also automatically attached.\n\nIn particular, when loading `pubh` the following packages are loaded too:\n\n-   `emmeans`\n-   `ggformula`\n-   `magrittr`\n-   `huxtable`\n-   `gtsummary`\n\nThe `tidyverse` loads a collection of packages:\n\n-   `dplyr`\n-   `forcats`\n-   `ggplot2`\n-   `purrr`\n-   `readr`\n-   `stringr`\n-   `tibble`\n-   `tidyr`\n\nWhen we load package `easystats` the following packages are loaded:\n\n-   `insight`\n-   `bayestestR`\n-   `parameters`\n-   `modelbased`\n-   `see`\n-   `datawizard`\n-   `effectsize`\n-   `correlation`\n-   `report`\n\nSometimes, we would like to load more packages either because of a particular function or because we would like to access data from that library. We use the function `library` to load a package; for example, to load the `ISwR` package (ISwR stands for *Introductory Statistics with R*), we type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ISwR)\n```\n:::\n\n\nA list of most of the available `R` packages can be found at the [CRAN](https://cran.r-project.org/) web page, under *Packages*. Libraries associated with Bioinformatics can be found at the [Bioconductor](http://www.bioconductor.org/) web page. Finally, packages organised by topic, can be found [here](https://cran.r-project.org/web/views/).\n\nTo install a new package, you can go to the *Display* panel, and click on *Install* under the *Packages* tab.\n\nAnother option is to type the command in the *Console* panel. For example, to install the `epibasix` package we type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"epibasix\")\n```\n:::\n\n\n## Objects in `R`\n\n### Short-cuts\n\nThe following are important short-cuts that we can use in `RStudio`:\n\n| Function   | Output | MacOS Short-cut   | Windows Short-cut |\n|------------|--------|-------------------|-------------------|\n| Assignment | `<-`   | `Option -`        | `Alt -`           |\n| Pipe       | `%>%`  | `Shift Command M` | `Shift Ctl M`     |\n\n| Action                           | MacOS Short-cut    | Windows Short-cut |\n|----------------------------------|--------------------|-------------------|\n| Insert Chunk                     | `Option Command I` | `Alt Ctl I`       |\n| Run line/selection               | `Command Return`   | `Ctl Return`      |\n| Formats text selection as `code` | `Command D`        | `Ctl D`           |\n\n### Assignments\n\nAn excellent introduction to `R` and its objects, can be found in the first chapter of [@iswr].\n\n:::{.callout-note}\nFrom now on, copy all the `R` commands in your script file (your *RMarkdown* Notebook). Be free to add text to comment or to change options or variables.\n:::\n\nA variable that holds a number or character is known as a *scalar*. Assignments are done with `<-` with no space between the two symbols. Assignments can also be done using the equal `=` symbol. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 5\nx + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n\nWhen a variable, holds 2 or more numbers or characters, is called a *vector*. For example, a vector of 3 weights (in pounds) is generated using the command `c` (concatenate):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweight = c(151.45, 194, 121.25)\n```\n:::\n\n\nThe advantage of vectors is that operations become faster than performing single operations. For example, let's say that we want to convert the weight in pounds to kg, and we do not want to have another variable, so just replace the old one. One kg equals 2.2046 pounds:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweight = weight/2.2046\nweight\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 68.69727 87.99782 54.99864\n```\n:::\n:::\n\n\nThere is no way we could measure human weight with that accuracy using standard devices, so let's round the values. First, look at the help file of `round`. The default is `digits = 0` (i.e., no decimals). We are going to keep one decimal. As `round` has no other option, we can directly type the value of `x` (our *object*) and the number of digits. In other occasions, for clarity, we will type things like `digits = 1`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(weight, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 68.7 88.0 55.0\n```\n:::\n:::\n\n\n### Pipe-work flow\n\n`R` is a computer language, thus, functions are performed from the most nested ones, to the less ones. For example, if we want to estimate the mean value of the vector of weights that we created, and report only one digit, we write:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(mean(weight, na.rm = TRUE), 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 70.6\n```\n:::\n:::\n\n\nWhen we have several parentheses, it's easy to get lost on the code. One option is to use a pipe-work flow. Package `magrittr` uses the command `%>%` to pass information in what is known as *pipe-work flow*. In this case, commands are simply read from left to right and top to bottom:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweight %>%\n  mean(na.rm = TRUE) %>%\n  round(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 70.6\n```\n:::\n:::\n\n\nTo *remove* (clear) objects from the workspace, we use `rm`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(x, weight)\n```\n:::\n\n\n## Generating data\n\nFor small datasets, the easiest thing to do is to generate the data directly in `R`. We will start by entering some data of our own. This particular dataset describes the levels of uric acid in the bloodstream of twenty subjects aged from 21 to 25. There were five individuals with each combination of Down's syndrome being present/absent and sex being male/female.\n\nThe variable `uric` contains the values for the uric acid, the variable `downs` contains numerical values for Down's syndrome (0 = \"No\", 1 = \"Yes\") and the variable `sex` contains numerical values representing sex (0 = \"Male\", 1 = \"Female\").\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuric_down = tibble(\n  uric = c(5.84, 6.3, 6.95, 5.92, 7.94, 5.5, 6.08, 5.12, 7.58, 6.78,\n           4.9, 6.95, 6.73, 5.32, 4.81, 4.94, 7.2, 5.22, 4.6, 3.88),\n  downs = c(rep(0, 5), rep(1, 5), rep(0, 5), rep(1, 5)),\n  sex = c(rep(0, 10), rep(1, 10))\n)\n```\n:::\n\n\nWe used the `rep` (replicate) command for both `downs` and `sex`. In the case of `downs`, it alternates 5 zeros (meaning \"No\") and 5 ones (meaning \"Yes\"). For sex, we are entering the males first (10 of them) and the females later (10 of them).\n\nThe most common way to work with data sets in `R` are `data.frames`. A data frame is a rectangular object in which all components (variables) have the same length. A data frame can have variables of different nature (character, logical, double, etc), but each one of them of a single nature and all of them of the same length. A modern version of data frames are `tibbles`.\n\nWe can look at all columns but only the first rows of the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuric_down %>% head() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n   uric downs   sex\n  <dbl> <dbl> <dbl>\n1  5.84     0     0\n2  6.3      0     0\n3  6.95     0     0\n4  5.92     0     0\n5  7.94     0     0\n6  5.5      1     0\n```\n:::\n:::\n\n\n### Categorical variables: Factors\n\nWhen we defined the data set `uric_down`, we used only numbers. Both `downs` and `sex` are categorical variables. A categorical variable in `R` is known as `factor`. Each `factor` contains two or more `levels` or *categories*.\n\nTo convert the variable `sex` from the data set `uric_down` to a factor we use the command `factor` indicating the names of the `levels` for each category in the same order as the corresponding sequence of numbers.\n\nIn this kind of operation, we need to give information of the variable, the name of the dataset and the actual function with options. One way to accomplish this, would be (please do **NOT** run):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuric_down$sex = factor(uric_down$sex, labels = c(\"Male\", \"Female\"))\n```\n:::\n\n\nIf you understood the instructions, you did NOT run the previous code! Alas, we need to explain.\n\nThe name of the variable is `sex` and the name of the dataset is `uric_down`. We use the `$` symbol to give an address, like saying:\n\n> *Variable `sex` lives at `uric_down`.*\n\nWe would need to do something similar to convert `downs` to a `factor`.\n\nWe will use a different approach, one more elegant, modern and *posh* (just saying!). We will use a pipe-workflow to transform variables.\n\nPackage `magrittr` introduced the concept of *pipes* in `R`; it's like passing information between objects and functions. The symbol to *pass* or *pipe* the information is `%>%`.\n\n:::{.callout-caution}\nIn some cases, when a function (usually an old function) does not contain `data` as part of its arguments, we use `%$%` instead.\n:::\n\nFor the conversion to factors, we use the function `mutate` from the `dplyr` package.\n\nLet's transform `downs` and `sex` from numerical (`double`) to categorical (`factor`) variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuric_down2 = uric_down %>%\n  mutate(\n    downs = factor(downs, labels = c(\"No\", \"Yes\")),\n    sex = factor(sex, labels = c(\"Male\", \"Female\"))\n  ) \n\nuric_down2 %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n   uric downs sex  \n  <dbl> <fct> <fct>\n1  5.84 No    Male \n2  6.3  No    Male \n3  6.95 No    Male \n4  5.92 No    Male \n5  7.94 No    Male \n6  5.5  Yes   Male \n```\n:::\n:::\n\n\n### Labels\n\nWe would also like to display more information than the current variable name, in tables and figures. To accomplish this, we associate `labels` with variables. We will use `var_labels` from the `sjlabelled` package. Notice, that the way we assign labels is similar to the one we used for transformations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuric_down2 = uric_down2 %>%\n  var_labels(\n    uric = \"Uric acid (mg/dl)\",\n    downs = \"Down's syndrome\",\n    sex = \"Sex\"\n  )\n```\n:::\n\n\nFor small datasets (like our current one) it is easier to make the transformation and the labelling as part of the same pipe-workflow.\n\nWe had not modified the original data set `uric_down`, instead, we created a new one `uric_down2`, so we could go one step at a time. You can remove `uric_down2` with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(uric_down2)\n```\n:::\n\n\nTo do both, transformation and labelling in the same pipe-workflow, we type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuric_down = uric_down %>%\n  mutate(\n    downs = factor(downs, labels = c(\"No\", \"Yes\")),\n    sex = factor(sex, labels = c(\"Male\", \"Female\"))\n  ) %>%\n  var_labels(\n    uric = \"Uric acid (mg/dl)\",\n    downs = \"Down's syndrome\",\n    sex = \"Sex\"\n  )\n```\n:::\n\n\n## Saving `R` data frames\n\nThe advantage of saving data frames as `R` data (`.rds`) is that `R` will have access to factors, levels and labels. I will save the data on the subdirectory *data*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(uric_down, \"data/uric_down.rds\")\n```\n:::\n\n\nIf you are following instructions, you have everything recorded in your script in case you did something wrong. To show how to import, we will remove all objects associated with the data frame first:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(uric_down)\n```\n:::\n\n\nTo load the data, we use `read_rds` and assign the file to a new object (in this case, a tibble). For simplicity, I use the same name of the file as the name of the new data frame, but you can change that.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuric_down = read_rds(\"data/uric_down.rds\")\nuric_down %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n   uric downs sex  \n  <dbl> <fct> <fct>\n1  5.84 No    Male \n2  6.3  No    Male \n3  6.95 No    Male \n4  5.92 No    Male \n5  7.94 No    Male \n6  5.5  Yes   Male \n```\n:::\n:::\n\n\n## Variables in data frames\n\nThe `uric_down` data frame has three variables. `R` can have more than one data frame loaded on the same session, that feature has the disadvantage that we need to tell `R` where to find individual variables.\n\nFor example, `uric_down` has a vector (variable) named `sex`. We could have another data frame which also has the variable `sex`, how do we know which one we are analysing? We have to give information of both the data frame and the vector. One way is by using the `$` symbol. The syntax is:\n\n**data\\$vector**\n\nFor example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuric_down$sex\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] Male   Male   Male   Male   Male   Male   Male   Male   Male   Male  \n[11] Female Female Female Female Female Female Female Female Female Female\nattr(,\"label\")\n[1] Sex\nLevels: Male Female\n```\n:::\n:::\n\n\nAnother option is to **select** the variables (columns) we are interested in:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuric_down %>%\n  select(sex, downs) %>%\n  frq()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSex (sex) <categorical> \n# total N=20 valid N=20 mean=1.50 sd=0.51\n\nValue  |  N | Raw % | Valid % | Cum. %\n--------------------------------------\nMale   | 10 |    50 |      50 |     50\nFemale | 10 |    50 |      50 |    100\n<NA>   |  0 |     0 |    <NA> |   <NA>\n\nDown's syndrome (downs) <categorical> \n# total N=20 valid N=20 mean=1.50 sd=0.51\n\nValue |  N | Raw % | Valid % | Cum. %\n-------------------------------------\nNo    | 10 |    50 |      50 |     50\nYes   | 10 |    50 |      50 |    100\n<NA>  |  0 |     0 |    <NA> |   <NA>\n```\n:::\n:::\n\n\nAn alternative to `$` is the function `with`. The syntax is: `with(data, function(x))`. For example, if we want to know if `sex` is a factor we can type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(uric_down, is.factor(sex))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nOr using pipes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuric_down %$% is.factor(sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nThe same command using the `$` symbol:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.factor(uric_down$sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n:::{.callout-important}\nThe `attach` command allows to access variables within data frames directly, however, it's not convenient when you work with more than one data set on the same session.\n:::\n\nIn the current example, the last command was simpler but in many cases is better to use `%>%`.\n\n## Export and import objects\n\nTo export a data frame (or other objects) to *Excel*, we will write `.csv` files (comma-separated values). In the following code, the file will be saved in the subdirectory `data`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_csv(uric_down, \"data/uric_down.csv\")\n```\n:::\n\n\nFor importing data from *Excel*, remember to:\n\n1.  Don't use complicated names for the variables, in particular:\n\n-   Don't start a variable name with a number.\n-   Don't leave spaces as part of the name, e.g. don't use `blood pressure`. Some alternatives are:\n    -   `blood_pressure`\n    -   `bp`\n    -   `blood.pressure`\n    -   `BloodPressure`\n\n2.  Don't use a long, complicated name for the name of your file; it is better to avoid spaces.\n3.  Don't leave cells blank (without any information). For missing data, we will type `NA`.\n4.  It is easier to record only numbers and to add labels on `R` later, to avoid mistakes on the names (it's not the same `female`, `Female`, or `female` with a blank space before the `f`).\n5.  Export your data as *comma-separated values* (.csv).\n\nLet's load our data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuric_down = read_csv(\"data/uric_down.csv\", col_types = \"dff\")\nuric_down %>% glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 20\nColumns: 3\n$ uric  <dbl> 5.84, 6.30, 6.95, 5.92, 7.94, 5.50, 6.08, 5.12, 7.58, 6.78, 4.90…\n$ downs <fct> No, No, No, No, No, Yes, Yes, Yes, Yes, Yes, No, No, No, No, No,…\n$ sex   <fct> Male, Male, Male, Male, Male, Male, Male, Male, Male, Male, Fema…\n```\n:::\n:::\n\n\n:::{.callout-note}\n1.  It's also possible to load *.csv* files using `read.csv`.\n2.  When we use `read.csv` the data is loaded as a data frame, whereas when we use `read_csv` the data is loaded as a tibble.\n3.  For data frames (using `read.csv`), variables with characters are transformed directly as factor, hence the command: `uric_down = read.csv(\"data/uric_down.csv\")` would be enough.\n4.  For tibbles (using `read_csv`), variables with characters remain characters unless we declare them as factor. The argument: `col_types = \"dff\"` indicates that the first variable is a *double* and the next two are *factors*.\n\nAnother way to import datasets is by going to the **Environment** tab, under the **Workspace** panel. There you can go to `Import Dataset > From CSV...`.\n:::\n\n:::{.callout-tip}\n**The following strategy is recommended:**\n\n1.  Load all your data in an Excel spreadsheet, remembering all points mentioned earlier.\n2.  Save your data in Excel format and also export it as a `.csv` file.\n3.  Import your data in `R`.\n4.  Define factors and labels.\n5.  Once you are happy with your data, save it as a `.rds` file with `write_rds`.\n6.  Perform your analysis with your data and document everything on a script file.\n:::\n\n## Data manipulation\n\nIn most cases you start by inspecting your data, cleaning, defining factors and making transformations. As mentioned in the section before, your data will come from a spreadsheet. In this paper, we will use data contained in `R` *packages* most of the time.\n\nFirst read the help file for the dataset `wcgs` by typing: `?epitools::wcgs` in the **Console** panel.\n\nWe use the function `data` to load data from `R` *packages*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(wcgs, package = \"epitools\")\nnames(wcgs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"id\"      \"age0\"    \"height0\" \"weight0\" \"sbp0\"    \"dbp0\"    \"chol0\"  \n [8] \"behpat0\" \"ncigs0\"  \"dibpat0\" \"chd69\"   \"typechd\" \"time169\" \"arcus0\" \n```\n:::\n:::\n\n\nThe first thing I would like to do is to change the name of the variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs = as_tibble(wcgs)\nnames(wcgs) = c(\n  \"id\", \"age\", \"height\", \"weight\", \"sbp\", \"dbp\",\n  \"chol\", \"beh_pat\", \"ncigs\", \"dib_pat\", \"chd\",\n  \"type_chd\", \"time\", \"arcus\"\n  )\n\nwcgs %>% names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"id\"       \"age\"      \"height\"   \"weight\"   \"sbp\"      \"dbp\"     \n [7] \"chol\"     \"beh_pat\"  \"ncigs\"    \"dib_pat\"  \"chd\"      \"type_chd\"\n[13] \"time\"     \"arcus\"   \n```\n:::\n:::\n\n\n### Defining factors\n\nNow, we define categorical variables as factors. By default, the value zero is our reference.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs = wcgs %>%\n  mutate(\n    chd = factor(chd, labels = c(\"No CHD\", \"CHD\")),\n    arcus = factor(arcus, labels = c(\"Absent\", \"Present\")),\n    beh_pat = factor(beh_pat, labels = c(\"A1\", \"A2\", \"B3\", \"B4\")),\n    dib_pat = factor(dib_pat, labels = c(\"B\", \"A\")),\n    type_chd = factor(type_chd, labels = c(\"No CHD\", \"MI or SD\", \"Angina\", \"Silent MI\"))\n  )\n```\n:::\n\n\n### Transforming to a binary variable\n\nOne of our variables is a count and stores the number of smoked cigarettes/day. We can define a new variable `Smoker` in which, everyone who smokes one or more cigarette/day will be a smoker. One of the easiest ways to create binary variables is to use a *conditional* statement. For example, the result of `wcgs$ncigs > 0` is a vector with `TRUE` and `FALSE` results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs = wcgs %>%\n  mutate(\n    smoker = factor(ncigs > 0, labels=c(\"Non-Smoker\", \"Smoker\"))\n  )\n```\n:::\n\n\n### Simple numeric transformations\n\nWe also, prefer units in the metric system. We will convert from inches to centimetres and from pounds to kg.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs = wcgs %>%\n  mutate(\n    height = height * 2.54,\n    weight = weight * 0.4536\n  )\n```\n:::\n\n\n### Changing the reference for factors\n\nFirst, check the reference level for the variable `dib_pat`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(wcgs$dib_pat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"B\" \"A\"\n```\n:::\n:::\n\n\nIt would make more sense to have `A` as our reference category.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs = wcgs %>%\n  mutate(dib_pat = relevel(dib_pat, ref = \"A\"))\n```\n:::\n\n\n### Labels\n\nIt is also helpful to add labels to variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs = wcgs %>%\n  var_labels(\n    age =  \"Age (years)\",\n    height = \"Height (cm)\",\n    weight = \"Weight (kg)\",\n    sbp = \"SBP (mm Hg)\",\n    dbp = \"DBP (mm Hg)\",\n    chol = \"Cholesterol (mg/dl)\",\n    beh_pat = \"Behaviour pattern\",\n    ncigs = \"Cigarettes (n/day)\",\n    dib_pat = \"Dichotomous behaviour\",\n    chd = \"Coronary Heart Disease\",\n    type_chd = \"Type of CHD\",\n    time = \"Follow up time (days)\",\n    arcus = \"Corneal arcus\",\n    smoker = \"Smoking status\"\n  )\n```\n:::\n\n\n> **Exercise:** Take a *glimpse* of your new data frame and save it as `wcgs.rds` file for further use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs %>% glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 3,154\nColumns: 15\n$ id       <int> 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2…\n$ age      <int> 49, 42, 42, 41, 59, 44, 44, 40, 43, 42, 53, 41, 50, 43, 44, 5…\n$ height   <dbl> 185.42, 177.80, 175.26, 172.72, 177.80, 182.88, 182.88, 180.3…\n$ weight   <dbl> 68.0400, 72.5760, 72.5760, 68.9472, 68.0400, 92.5344, 74.3904…\n$ sbp      <int> 110, 154, 110, 124, 144, 150, 130, 138, 146, 132, 146, 138, 1…\n$ dbp      <int> 76, 84, 78, 78, 86, 90, 84, 60, 76, 90, 94, 96, 90, 80, 80, 8…\n$ chol     <int> 225, 177, 181, 132, 255, 182, 155, 140, 149, 325, 223, 271, 2…\n$ beh_pat  <fct> A2, A2, B3, B4, B3, B4, B4, A2, B3, A2, A2, A2, A1, B3, B3, B…\n$ ncigs    <int> 25, 20, 0, 20, 20, 0, 0, 0, 25, 0, 25, 20, 50, 30, 0, 3, 9, 0…\n$ dib_pat  <fct> A, A, B, B, B, B, B, A, B, A, A, A, A, B, B, B, B, A, B, A, A…\n$ chd      <fct> No CHD, No CHD, No CHD, No CHD, CHD, No CHD, No CHD, No CHD, …\n$ type_chd <fct> No CHD, No CHD, No CHD, No CHD, MI or SD, No CHD, No CHD, No …\n$ time     <int> 1664, 3071, 3071, 3064, 1885, 3102, 3074, 3071, 3064, 1032, 3…\n$ arcus    <fct> Absent, Present, Absent, Absent, Present, Absent, Absent, Abs…\n$ smoker   <fct> Smoker, Smoker, Non-Smoker, Smoker, Smoker, Non-Smoker, Non-S…\n```\n:::\n\n```{.r .cell-code}\nwrite_rds(wcgs, \"data/wcgs.rds\")\n```\n:::\n\n\n### Indexing and subsets\n\nLet's said that we are only interested in subjects who are smokers. If that is the case, we can create a new data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmokers = wcgs %>%\n  filter(smoker == \"Smoker\") %>%\n  copy_labels(wcgs)\n```\n:::\n\n\n:::{.callout-note}\nWhen we are making comparisons, we use double equals; single equals in `R` are used for assignments and double ones for comparisons. For comparing against a character, we have to use single or double quotes (as shown in code above); numbers are not quoted.\n:::\n\nOne way to check that we did not make a terrible mistake, is to check for the number of observations. The number of observations on a data frame is, most of the time, equal to the number of rows (`nrow`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs %>% nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3154\n```\n:::\n\n```{.r .cell-code}\nsmokers %>% nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1502\n```\n:::\n:::\n\n\nThe function `nrow` works on *arrays*, i.e., data frames and matrices. For vectors, we use the function `length` instead. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(wcgs$smoker)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3154\n```\n:::\n:::\n\n\nAnother important concept is that of *indexing*. For indexing, we write the conditional inside square brackets. For example, another way to look at the number of smokers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(wcgs$smoker[wcgs$smoker == \"Smoker\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1502\n```\n:::\n:::\n\n\nUsing `with`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(wcgs, length(smoker[smoker == \"Smoker\"]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1502\n```\n:::\n:::\n\n\nUsing a pipe-workflow:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs %>% count(smoker)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  smoker         n\n  <fct>      <int>\n1 Non-Smoker  1652\n2 Smoker      1502\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs %>% frq(smoker) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSmoking status (smoker) <categorical> \n# total N=3154 valid N=3154 mean=1.48 sd=0.50\n\nValue      |    N | Raw % | Valid % | Cum. %\n--------------------------------------------\nNon-Smoker | 1652 | 52.38 |   52.38 |  52.38\nSmoker     | 1502 | 47.62 |   47.62 | 100.00\n<NA>       |    0 |  0.00 |    <NA> |   <NA>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs %>% freq_table(smoker)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  smoker         n  prop\n  <fct>      <int> <dbl>\n1 Non-Smoker  1652  52.4\n2 Smoker      1502  47.6\n```\n:::\n:::\n\n\nSuppose we want to know the number of smokers who weight 100 kg or more:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs %>%\n  filter(weight >= 100) %>%\n  count(smoker)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  smoker         n\n  <fct>      <int>\n1 Non-Smoker    28\n2 Smoker        20\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsmokers %>%\n  filter(weight >= 100) %>%\n  count()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n      n\n  <int>\n1    20\n```\n:::\n:::\n\n\nFor obtaining the same result, but working on the original dataset, we would need to use two conditionals. We use the symbol `&` for **AND** and the symbol `|` for **OR**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs %>%\n  filter(weight >= 100 & smoker == \"Smoker\") %>%\n  count()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n      n\n  <int>\n1    20\n```\n:::\n:::\n\n\n> **Exercise:** Determine the number of smokers who have behavioural pattern `A2` and had either angina or silent myocardial infarction. You will need to write the **OR** conditionals between parenthesis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmokers %>%\n  filter(beh_pat == \"A2\" & (type_chd == \"Angina\" | type_chd == \"Silent MI\")) %>%\n  count()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n      n\n  <int>\n1    38\n```\n:::\n:::\n\n\nIt's possible to answer the exercise using `%in%` which is a variant of the `match` command:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmokers %>%\n  filter(beh_pat == \"A2\" & type_chd %in% c(\"Angina\", \"Silent MI\")) %>%\n  count()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n      n\n  <int>\n1    38\n```\n:::\n:::\n\n\nLet's say we want to know all the variable values for the subject who has the maximum weight. The function `which` gives us the position for where the given condition is true. I will assign the result to a variable named `pos`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npos = wcgs %$% which(weight == max(weight))\npos\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1094\n```\n:::\n:::\n\n\nAlternatively, we can use `which.max`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs %$% which.max(weight)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1094\n```\n:::\n:::\n\n\nFor indexing arrays, we use square brackets. The first number refers to the row and the second to the column. If one of them is missing, that means we are asking for all the values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs[pos, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 15\n     id   age height weight   sbp   dbp  chol beh_pat ncigs dib_pat chd  \n  <int> <int>  <dbl>  <dbl> <int> <int> <int> <fct>   <int> <fct>   <fct>\n1 10078    43   193.   145.   166   102   188 B3          0 B       CHD  \n# ℹ 4 more variables: type_chd <fct>, time <int>, arcus <fct>, smoker <fct>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwcgs %>% \n  filter(id == id[pos])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 15\n     id   age height weight   sbp   dbp  chol beh_pat ncigs dib_pat chd  \n  <int> <int>  <dbl>  <dbl> <int> <int> <int> <fct>   <int> <fct>   <fct>\n1 10078    43   193.   145.   166   102   188 B3          0 B       CHD  \n# ℹ 4 more variables: type_chd <fct>, time <int>, arcus <fct>, smoker <fct>\n```\n:::\n:::\n",
    "supporting": [
      "intro_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}